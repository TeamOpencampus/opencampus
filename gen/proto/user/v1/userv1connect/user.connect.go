// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: proto/user/v1/user.proto

package userv1connect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	http "net/http"
	v1 "opencampus/gen/proto/user/v1"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// UserServiceName is the fully-qualified name of the UserService service.
	UserServiceName = "proto.user.v1.UserService"
)

// UserServiceClient is a client for the proto.user.v1.UserService service.
type UserServiceClient interface {
	Me(context.Context, *connect_go.Request[v1.MeRequest]) (*connect_go.Response[v1.MeResponse], error)
	Institutes(context.Context, *connect_go.Request[v1.InstitutesRequest]) (*connect_go.Response[v1.InstitutesResponse], error)
	JoinInstitute(context.Context, *connect_go.Request[v1.JoinInstituteRequest]) (*connect_go.Response[v1.JoinInstituteResponse], error)
	Jobs(context.Context, *connect_go.Request[v1.JobsRequest]) (*connect_go.Response[v1.JobsResponse], error)
	JobById(context.Context, *connect_go.Request[v1.JobByIdRequest]) (*connect_go.Response[v1.JobByIdResponse], error)
	Apply(context.Context, *connect_go.Request[v1.ApplyRequest]) (*connect_go.Response[v1.ApplyResponse], error)
	Retract(context.Context, *connect_go.Request[v1.RetractRequest]) (*connect_go.Response[v1.RetractResponse], error)
}

// NewUserServiceClient constructs a client for the proto.user.v1.UserService service. By default,
// it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and
// sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC()
// or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewUserServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) UserServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &userServiceClient{
		me: connect_go.NewClient[v1.MeRequest, v1.MeResponse](
			httpClient,
			baseURL+"/proto.user.v1.UserService/Me",
			opts...,
		),
		institutes: connect_go.NewClient[v1.InstitutesRequest, v1.InstitutesResponse](
			httpClient,
			baseURL+"/proto.user.v1.UserService/Institutes",
			opts...,
		),
		joinInstitute: connect_go.NewClient[v1.JoinInstituteRequest, v1.JoinInstituteResponse](
			httpClient,
			baseURL+"/proto.user.v1.UserService/JoinInstitute",
			opts...,
		),
		jobs: connect_go.NewClient[v1.JobsRequest, v1.JobsResponse](
			httpClient,
			baseURL+"/proto.user.v1.UserService/Jobs",
			opts...,
		),
		jobById: connect_go.NewClient[v1.JobByIdRequest, v1.JobByIdResponse](
			httpClient,
			baseURL+"/proto.user.v1.UserService/JobById",
			opts...,
		),
		apply: connect_go.NewClient[v1.ApplyRequest, v1.ApplyResponse](
			httpClient,
			baseURL+"/proto.user.v1.UserService/Apply",
			opts...,
		),
		retract: connect_go.NewClient[v1.RetractRequest, v1.RetractResponse](
			httpClient,
			baseURL+"/proto.user.v1.UserService/Retract",
			opts...,
		),
	}
}

// userServiceClient implements UserServiceClient.
type userServiceClient struct {
	me            *connect_go.Client[v1.MeRequest, v1.MeResponse]
	institutes    *connect_go.Client[v1.InstitutesRequest, v1.InstitutesResponse]
	joinInstitute *connect_go.Client[v1.JoinInstituteRequest, v1.JoinInstituteResponse]
	jobs          *connect_go.Client[v1.JobsRequest, v1.JobsResponse]
	jobById       *connect_go.Client[v1.JobByIdRequest, v1.JobByIdResponse]
	apply         *connect_go.Client[v1.ApplyRequest, v1.ApplyResponse]
	retract       *connect_go.Client[v1.RetractRequest, v1.RetractResponse]
}

// Me calls proto.user.v1.UserService.Me.
func (c *userServiceClient) Me(ctx context.Context, req *connect_go.Request[v1.MeRequest]) (*connect_go.Response[v1.MeResponse], error) {
	return c.me.CallUnary(ctx, req)
}

// Institutes calls proto.user.v1.UserService.Institutes.
func (c *userServiceClient) Institutes(ctx context.Context, req *connect_go.Request[v1.InstitutesRequest]) (*connect_go.Response[v1.InstitutesResponse], error) {
	return c.institutes.CallUnary(ctx, req)
}

// JoinInstitute calls proto.user.v1.UserService.JoinInstitute.
func (c *userServiceClient) JoinInstitute(ctx context.Context, req *connect_go.Request[v1.JoinInstituteRequest]) (*connect_go.Response[v1.JoinInstituteResponse], error) {
	return c.joinInstitute.CallUnary(ctx, req)
}

// Jobs calls proto.user.v1.UserService.Jobs.
func (c *userServiceClient) Jobs(ctx context.Context, req *connect_go.Request[v1.JobsRequest]) (*connect_go.Response[v1.JobsResponse], error) {
	return c.jobs.CallUnary(ctx, req)
}

// JobById calls proto.user.v1.UserService.JobById.
func (c *userServiceClient) JobById(ctx context.Context, req *connect_go.Request[v1.JobByIdRequest]) (*connect_go.Response[v1.JobByIdResponse], error) {
	return c.jobById.CallUnary(ctx, req)
}

// Apply calls proto.user.v1.UserService.Apply.
func (c *userServiceClient) Apply(ctx context.Context, req *connect_go.Request[v1.ApplyRequest]) (*connect_go.Response[v1.ApplyResponse], error) {
	return c.apply.CallUnary(ctx, req)
}

// Retract calls proto.user.v1.UserService.Retract.
func (c *userServiceClient) Retract(ctx context.Context, req *connect_go.Request[v1.RetractRequest]) (*connect_go.Response[v1.RetractResponse], error) {
	return c.retract.CallUnary(ctx, req)
}

// UserServiceHandler is an implementation of the proto.user.v1.UserService service.
type UserServiceHandler interface {
	Me(context.Context, *connect_go.Request[v1.MeRequest]) (*connect_go.Response[v1.MeResponse], error)
	Institutes(context.Context, *connect_go.Request[v1.InstitutesRequest]) (*connect_go.Response[v1.InstitutesResponse], error)
	JoinInstitute(context.Context, *connect_go.Request[v1.JoinInstituteRequest]) (*connect_go.Response[v1.JoinInstituteResponse], error)
	Jobs(context.Context, *connect_go.Request[v1.JobsRequest]) (*connect_go.Response[v1.JobsResponse], error)
	JobById(context.Context, *connect_go.Request[v1.JobByIdRequest]) (*connect_go.Response[v1.JobByIdResponse], error)
	Apply(context.Context, *connect_go.Request[v1.ApplyRequest]) (*connect_go.Response[v1.ApplyResponse], error)
	Retract(context.Context, *connect_go.Request[v1.RetractRequest]) (*connect_go.Response[v1.RetractResponse], error)
}

// NewUserServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewUserServiceHandler(svc UserServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/proto.user.v1.UserService/Me", connect_go.NewUnaryHandler(
		"/proto.user.v1.UserService/Me",
		svc.Me,
		opts...,
	))
	mux.Handle("/proto.user.v1.UserService/Institutes", connect_go.NewUnaryHandler(
		"/proto.user.v1.UserService/Institutes",
		svc.Institutes,
		opts...,
	))
	mux.Handle("/proto.user.v1.UserService/JoinInstitute", connect_go.NewUnaryHandler(
		"/proto.user.v1.UserService/JoinInstitute",
		svc.JoinInstitute,
		opts...,
	))
	mux.Handle("/proto.user.v1.UserService/Jobs", connect_go.NewUnaryHandler(
		"/proto.user.v1.UserService/Jobs",
		svc.Jobs,
		opts...,
	))
	mux.Handle("/proto.user.v1.UserService/JobById", connect_go.NewUnaryHandler(
		"/proto.user.v1.UserService/JobById",
		svc.JobById,
		opts...,
	))
	mux.Handle("/proto.user.v1.UserService/Apply", connect_go.NewUnaryHandler(
		"/proto.user.v1.UserService/Apply",
		svc.Apply,
		opts...,
	))
	mux.Handle("/proto.user.v1.UserService/Retract", connect_go.NewUnaryHandler(
		"/proto.user.v1.UserService/Retract",
		svc.Retract,
		opts...,
	))
	return "/proto.user.v1.UserService/", mux
}

// UnimplementedUserServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedUserServiceHandler struct{}

func (UnimplementedUserServiceHandler) Me(context.Context, *connect_go.Request[v1.MeRequest]) (*connect_go.Response[v1.MeResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("proto.user.v1.UserService.Me is not implemented"))
}

func (UnimplementedUserServiceHandler) Institutes(context.Context, *connect_go.Request[v1.InstitutesRequest]) (*connect_go.Response[v1.InstitutesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("proto.user.v1.UserService.Institutes is not implemented"))
}

func (UnimplementedUserServiceHandler) JoinInstitute(context.Context, *connect_go.Request[v1.JoinInstituteRequest]) (*connect_go.Response[v1.JoinInstituteResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("proto.user.v1.UserService.JoinInstitute is not implemented"))
}

func (UnimplementedUserServiceHandler) Jobs(context.Context, *connect_go.Request[v1.JobsRequest]) (*connect_go.Response[v1.JobsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("proto.user.v1.UserService.Jobs is not implemented"))
}

func (UnimplementedUserServiceHandler) JobById(context.Context, *connect_go.Request[v1.JobByIdRequest]) (*connect_go.Response[v1.JobByIdResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("proto.user.v1.UserService.JobById is not implemented"))
}

func (UnimplementedUserServiceHandler) Apply(context.Context, *connect_go.Request[v1.ApplyRequest]) (*connect_go.Response[v1.ApplyResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("proto.user.v1.UserService.Apply is not implemented"))
}

func (UnimplementedUserServiceHandler) Retract(context.Context, *connect_go.Request[v1.RetractRequest]) (*connect_go.Response[v1.RetractResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("proto.user.v1.UserService.Retract is not implemented"))
}
